# 大纲

1. 引出事件循环，明确中心思想
2. 解释事件循环机制，
3. 模拟事件循环（）

# 前言

众所周知，JS 在主线程上单线程执行，并通过事件循环（Event Loop）机制来实现异步操作的处理。

本文将梳理事件循环机制的执行流程，并尝试模拟其中对事件队列的处理机制。

# 事件循环

JS 在设计之初的目的是用于操作 DOM，为了避免多个线程同时操作 DOM 引发冲突，所以 JS 就被设计为单线程。

而在单线程环境中，想要处理异步操作，JS 使用的则是事件循环机制。

事件循环机制有两个重点概念：

1. 调用栈
2. 任务队列

调用栈是 JS 主线程用于跟踪当前正在执行的函数的方式。当函数被调用时，会被压入栈，执行完毕则弹出栈。

事件循环机制将异步操作分为两大类，分别是`宏任务` 和 `微任务`，任务队列则`宏任务队列` 和 `微任务队列`的统称。

宏任务与微任务的具体分类如下：

- 宏任务：script 标签、setTimeout、setInterval、UI 交互事件
- 微任务：Promise、MutationObserver

事件循环机制的执行流程如下：

1. 执行主任务（遇到宏任务时，将其加入宏任务队列的队尾。微任务同理。）。
2. 执行微任务：按顺序清空微任务队列（处理宏任务、微任务的逻辑与第一步相同）。
3. 判断是否需要渲染页面（由浏览器自动判断）。
4. 执行宏任务：取出宏任务队列的第一个任务，执行之（处理宏任务、微任务的逻辑与第一步相同）。
5. 重复循环第二、第三、第四步，直至任务队列为空。

示意图：
![事件循环](../assets/images/事件循环.png)

# 拓展：页面帧与事件循环

所谓的“帧”可理解为“周期”，举个例子：如果当前页面每秒刷新 60 次，那么它的刷新率就是 60hz，即每秒 60 个周期/帧。也就是说（刷新率为 60hz 时）每帧的时间为 1s / 60 = 16.6ms。

每一帧是一个周期循环，浏览器需要在每一帧中执行重复的任务，以保持页面能正常展示与使用。

具体来说，浏览器每一帧需要做的事可按执行顺序归纳为：

1. 事件循环机制（尽可能多地执行宏任务与微任务）
2. 执行(requestAnimationFrame)[https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame]
3. 页面渲染
4. （如有空闲时间）执行(requestIdleCallback)[https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback]

示意图：
![页面帧](../assets/images/页面帧.png)

可以发现，页面每一帧的第一件事就是运行事件循环机制，它并非是一个抽象的机制，而是切实地发生在每一个 16.6 毫秒中的机制。希望结合页面帧，能让大家对事件循环机制有更具象的理解。

# 模拟事件循环机制

## 目标

> 模仿浏览器事件循环机制，实现：
>
> 1. 执行主任务。
> 2. 清空微任务队列。
> 3. 取出第一个宏任务并执行。
> 4. 循环第二、第三步，直至任务队列为空。

为了使整个模拟逻辑能走通，现使用自定义的 `pushMacro` 和 `pushMicro` 方法分别代表宏任务和微任务，使用方式如下所示：

```javascript
// 模拟宏任务
pushMacro(() => {
  console.log("hello");
});
// 类比原生宏任务setTimeout
setTimeout(() => {
  console.log("hello");
});

// 模拟微任务
pushMicro(() => {
  console.log("hello");
});
// 类比原生微任务then函数
Promise.resolve().then(() => {
  console.log("hello");
});
```

## 任务

具体代码任务为：

1. 完善 pushMacro 和 pushMicro 方法
2. 编写 worker 函数，接收主任务 main 函数作为参数。其功能为模拟 JS 主线程执行主任务 mian 函数，并使事件循环机制能正常执行。

需求代码如下所示：

```javascript
// 添加微任务（需完善）
function pushMicro(fn) {}
// 添加宏任务（需完善）
function pushMacro(fn) {}
// 模拟JS主线程（需完善）
function worker() {}

// 主任务
const main = () => {
  console.log("a");
  pushMicro(() => {
    console.log("b");
    pushMicro(() => {
      console.log("c");
    });
    pushMacro(() => {
      console.log("d");
    });
  });
  pushMacro(() => {
    console.log("e");
  });
  console.log("f");
};

worker(main); // 运行后输出：a, f, b, c, e, d
```

## 具体实现

```javascript
//微任务队列
const microQueue = [];
// 宏任务队列
const macroQueue = [];

// 添加微任务
function pushMicro(fn) {
  microQueue.push(fn);
}
// 添加宏任务
function pushMacro(fn) {
  macroQueue.push(fn);
}

function worker(callback) {
  // 处理任务队列（宏任务 + 微任务）
  function handleQueue() {
    // 清空微任务队列
    while (microQueue.length) {
      const fn = microQueue.shift();
      fn();
    }

    // 执行宏任务队列的第一个任务
    if (macroQueue.length) {
      const fn = macroQueue.shift();
      fn();
    }

    // 重新清空微任务队列，并执行一个宏任务
    if (microQueue.length || macroQueue.length) handleQueue();
  }

  callback();
  handleQueue();
}

// 主任务
const main = () => {
  console.log("a");
  pushMicro(() => {
    console.log("b");
    // 微任务中添加了新的微任务，也会在同一轮的事件循环中一起被清空
    pushMicro(() => {
      console.log("c");
    });
    pushMacro(() => {
      console.log("d");
    });
  });
  pushMacro(() => {
    console.log("e");
  });
  console.log("f");
};

worker(main); // 输出：a, f, b, c, e, d
```

# 疑惑

1. 讲解事件循环的时候，需要提到调用栈吗
2. 事件循环机制和题目的任务队列机制是一样的是吧
