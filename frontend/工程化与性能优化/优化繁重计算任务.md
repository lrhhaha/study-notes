










- 前言
从页面卡顿，引出对繁重计算任务的优化

- 为什么网页会卡顿
解释页面卡顿的原因：
1. 道理上
2. 原理上

- 具体优化
展示卡顿网页

-- 使用web Worker

-- 使用requestIdleCallback

- 总结






# 前言
从用户的角度评判一个网站的“优秀程度”，最直观的评价方式就是运行是否流畅，在页面渲染、用户交互时，是否会有卡顿感。

而造成视觉上卡顿的原因有很多，可能是：
1. 页面加载时一次性加载大量资源，导致用户等待页面绘制的时间过长。
2. script标签使用不当，阻塞了 HTML 文档的解析。
3. 在页面运行时，执行繁重的JS计算，导致阻塞页面的渲染

本文将讨论第三点：繁重的JS运算是如何造成网页卡顿的，以及缓解卡顿的方式。

# 为什么网页会卡顿
网页卡顿，即页面元素的变化不流畅，进行交互时有滞后感。如下图所示，元素的变化是不流畅的，


而本文讨论的`繁重JS运算导致页面卡顿`，可以从**道理上**和**原理上**进行理解

## 道理上
JS在设计之初的用途是操作DOM元素，而如果JS能在多个线程中执行，则代表DOM元素可能会同时被不同线程中的JS脚本进行操作，那么就可能出现冲突的情况。为了避免这种冲突的出现，**JS在一开始就被设计成单线程语言**。在同一时间只能执行一个脚本，运行其中的一条语句。

但仅仅被设计为单线程还不足以解决DOM元素冲突的问题。

浏览器需要解析HTML中的DOM结构，并将其渲染至页面上。试想一下，**如果页面渲染和JS代码运行同时发生**，那么就有可能造成浏览器一边根据 DOM 渲染页面，JS一边修改此 DOM，这就造成了冲突。所以浏览器被设计成，页面渲染和JS执行是互斥的，它俩不能同时执行。形成“页面渲染 - JS修改DOM - 页面渲染 - JS修改DON - ...”这种线性循环，完美的避免了冲突的问题。


上面的JS代码执行与页面渲染互斥的方案确实解决了两者冲突的问题，但同时也为页面卡顿留下了隐患：即在“页面渲染 - JS修改DOM”的循环过程中，如果JS需要执行长时间的任务，那么就会阻塞下一次页面的渲染，从而导致页面卡顿。这就是为什么从道理上说，繁重的JS运算可能会导致页面卡顿。

## 原理上
从原理上理解，可以归纳为一句话：`JS引擎长时间占用主线程，导致GUI渲染任务滞后`。

浏览器是一个多进程架构，可归纳为：
- 浏览器主进程
- GPU进程
- 渲染进程
- 网络进程
- 插件进程

而其中的渲染进程是我们前端开发中最常接触到的一个进程，它可以理解为我们常说的“浏览器内核”，主要负责把HTML、JS、CSS解析呈现为可交互的页面。而浏览器中的一个tab页，就对应着一个渲染进程。

而在渲染进程中，有一个鼎鼎大名的线程，叫做`主线程`。此页面中的，**JS引擎解析执行代码**和**GUI页面渲染任务**都是在此线程中执行的，两者共享主线程，为互斥的关系。

所以如果某段JS代码执行需要消耗比较长的时间，那么就会导致页面渲染被阻塞，在用户的视角上看，就会觉得页面是一卡一卡的。

# 优化
接下来我们将构造一个繁重的JS任务，展示它对页面渲染的影响，然后尝试使用两种方案进行优化。
## 卡顿情况
假设我们有一个需求，就是需要进行一千万次循环计算，以模拟应用中的极端繁重运算。
具体代码如下所示
```javascript
function heavyCalculation() {
    let result = 0;
    // 进行一千万次计算
    for (let i = 0; i < 10000000; i++) {
        result += Math.sqrt(i) * Math.sin(i) * Math.cos(i) * Math.tan(i)
    }
}
```
当直接运行代码，会出现下图所示的卡顿情况。

其中的原因也非常明显，就是JS引擎长时间占据主线程，导致GUI渲染任务无法执行，所以跳动的小球就被定住了。直至计算任务完成，主线程才能执行GUI渲染任务，小球才会重新跳动。

## 问题分析
上述出现页面卡顿的原因是需要进行一千万次的循环，所需的时间太长了，而对于这个长耗时的任务，我们有两个方案去解决

1. 将一个耗时长的任务拆分成多个耗时较短的任务，并将它们分散在多个“执行JS代码 - 页面渲染”的循环中，每次JS引擎只执行部分任务，将足够多的时间留给GUI渲染页面。
2. 将繁重的JS任务放在独立于主线程的工作线程中执行，这样就不会阻塞GUI渲染页面了。

### 使用requestIdleCallback拆分任务

























































