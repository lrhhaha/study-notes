# 任务

题目：**实现浏览器任务队列机制**

> 模仿浏览器任务队列机制，实现：
>
> 1. 执行主任务
> 2. 主任务执行完成后，判断是否有微任务，有则执行，直至微任务队列为空
> 3. 判断是否有宏任务，有则取出第一个，重新进行上述循环，直至宏任务队列为空。

使用如下方式模拟宏任务和微任务：

```javascript
// ========宏任务=========
// 宏任务
pushMacro(() => {
  console.log("hello");
});
// 类比原生宏任务setTimeout
setTimeout(() => {
  console.log("hello");
});

// ========微任务=============
// 微任务
pushMicro(() => {
  console.log("hello");
});
// 类似原生微任务then函数
Promise.resolve().then(() => {
  console.log("hello");
});
```

具体效果如下所示：

```javascript
// 添加微任务（待完善）
const pushMicro = (fn) => {};
// 添加宏任务（待完善）
const pushMacro = (fn) => {};

// 主任务，运行后输出：a, f, b, c, e, d
const main = () => {
  console.log("a");
  pushMicro(() => {
    console.log("b");
    pushMicro(() => {
      console.log("c");
    });
    pushMacro(() => {
      console.log("d");
    });
  });
  pushMacro(() => {
    console.log("e");
  });
  console.log("f");
};
```

> 需求：
>
> 1. 完善 pushMicro 和 pushMacro 函数，维护任务队列。
> 2. 编写 worker 函数，接收主任务 main 函数作为参数。使主任务函数能正常运行，并正确模拟浏览器的任务队列运行机制。

# 实现

```javascript
//微任务队列
const microQueue = [];
// 宏任务队列
const macroQueue = [];

// 添加微任务
const pushMicro = (fn) => microQueue.push(fn);
// 添加宏任务
const pushMacro = (fn) => macroQueue.push(fn);

// 主线程
const main = () => {
  console.log("a");
  pushMicro(() => {
    console.log("b");
    // 微任务中添加了新的微任务，也会在同一轮的事件循环中一起被清空
    pushMicro(() => {
      console.log("c");
    });
    pushMacro(() => {
      console.log("d");
    });
  });
  pushMacro(() => {
    console.log("e");
  });
  console.log("f");
};

function worker(callback) {
  // 处理任务队列（宏任务 + 微任务）
  function handleQueue() {
    // 清空微任务队列
    while (microQueue.length) {
      const fn = microQueue.shift();
      fn();
    }

    // 执行宏任务队列的第一个任务
    if (macroQueue.length) {
      const fn = macroQueue.shift();
      fn();
    }

    // 重新清空微任务队列，并执行一个宏任务
    if (microQueue.length || macroQueue.length) handleQueue();
  }

  callback();
  handleQueue();
}

worker(main); // 输出：a, f, b, c, e, d
```

# 理解与疑惑

## 原本的想法

我原本并不打算把 main 函数作为 worker 函数的参数，而是想让 mian()直接执行，然后也不需要 worker 来调用 main，而是直接使用 handleQueue 函数去处理任务队列。代码如下所示：

```javascript
const microQueue = [];
const macroQueue = [];

const pushMicro = (fn) => microQueue.push(fn);
const pushMacro = (fn) => macroQueue.push(fn);

const main = () => {
  console.log("a");
  pushMicro(() => {
    console.log("b");
    pushMicro(() => {
      console.log("c");
    });
    pushMacro(() => {
      console.log("d");
    });
  });
  pushMacro(() => {
    console.log("e");
  });
  console.log("f");
};

function handleQueue() {
  while (microQueue.length) {
    const fn = microQueue.shift();
    fn();
  }

  if (macroQueue.length) {
    const fn = macroQueue.shift();
    fn();
  }

  if (microQueue.length || macroQueue.length) handleQueue();
}

// 直接执行主任务
main(); // 输出：a, f, b, c, e, d
// 处理任务队列
handleQueue();
```

如上代码是可以正确处理普通的事件循环情况的。

## 处理特殊情况

但我考虑到了一种特殊情况：宏任务和微任务不是在主任务中添加的，而是在事件处理函数中添加进去的，这样上面代码的 handleQueue 就不能处理这类情况了，如下所示：

```javascript
function main() {
  // 可被正确处理
  pushMicro(() => {
    console.log("c");
  });

  const box = document.getElementById("my-box");
  box.addEventListener("click", () => {
    // 不可被正确处理
    pushMicro(() => {
      console.log("c");
    });
    pushMacro(() => {
      console.log("d");
    });
  });
}
```

为了正确执行这种不在主任务中添加的宏任务和微任务，我想到两种方式：

1. 轮询调用 handleQueue 方法，可以解决问题，但存在缺陷：
   1. 采用 requestAnimationFrame 轮询，但此函数每一帧只执行一次，可能会导致宏任务队列执行不及时
2. 修改函数执行的逻辑（此方法就是上面我采用的方法）。即任何函数的执行方式不再是使用括号调用，而是使用“执行器 worker”去执行，将要执行的函数作为 worker 的回调函数，在 worker 中执行回调，并处理任务队列。（这样的话，即使是在事件处理函数中添加的宏任务也能正确处理了，因为事件处理函数理论上也需要使用 worker 去执行）。
   1. 缺点：太抽象了，相当于自定义了 JS 底层逻辑。

## 疑惑

1. 真的有必要考虑事件处理函数这种特殊情况吗？还是说是我想太多了哈哈哈哈哈哈哈。
2. 如果我希望处理事件处理函数的情况，上述两种方式是可行的吗？或者是否有更好的方式去解决这个问题？
