## ES5 实现

```javascript
// 支持自定义扁平化深度控制
// 处理空数组和undefined元素

function flat(array, depth) {
  if (!Array.isArray(array)) {
    throw new TypeError("arguments[0] must be an array");
  }

  depth = depth ?? 1;

  const result = [];

  for (let i = 0; i < array.length; i++) {
    const item = array[i];

    if (Array.isArray(item) && depth > 0) {
      // flat的返回值是一个扁平化后的数组
      const newArr = flat(item, depth - 1);
      newArr.forEach((element) => result.push(element));
    } else {
      item !== undefined && result.push(item);
    }
  }

  return result;
}

console.log(flat([1, undefined, [2, 3], [4, []]], 2));
```

## ES6 实现

#### 基础实现

```javascript
function flat(array, depth) {
  if (!Array.isArray(array)) {
    throw new TypeError("arguments[0] must be an array");
  }

  depth = depth ?? 1;

  const result = [];

  for (let i = 0; i < array.length; i++) {
    const item = array[i];

    if (Array.isArray(item) && depth > 0) {
      // flat的返回值是一个扁平化后的数组
      const newArr = flat(item, depth - 1);
      result.push(...newArr);
    } else {
      item !== undefined && result.push(item);
    }
  }

  return result;
}
```

#### 挑战测试

##### reduce 版本：函数式编程风格，支持深度控制

```javascript
function flat(array, depth = 1) {
  if (!Array.isArray(array)) {
    throw new TypeError("arguments[0] must be an array");
  }

  return array.reduce((acc, curr) => {
    if (depth > 0 && Array.isArray(curr)) {
      return acc.concat(flat(curr, depth - 1));
    } else {
      return [...acc, curr];
    }
  }, []);
}

// =================
function flattenArrayWithDepth(arr, depth = 1) {
  return depth > 0
    ? arr.reduce((acc, item) => {
        if (Array.isArray(item)) {
          return acc.concat(flattenArrayWithDepth(item, depth - 1));
        } else {
          return acc.concat(item);
        }
      }, [])
    : arr.slice();
}
```

##### spread 版本：利用扩展运算符，简洁但只能完全扁平化

```javascript
function flat(array) {
  // 复制原数组，不修改原数组
  let result = [...array];
  while (result.some((item) => Array.isArray(item))) {
    result = [].concat(...result);
  }
  return result;
}
```

##### 迭代版本：使用栈结构，避免递归调用栈限制

```javascript
function flat(array, depth = 1) {
  const result = [];

  const stack = array.map((item) => ({ value: item, deep: 1 }));

  // 注意这里不能使用forEach等数组遍历函数，它们的遍历次数在一开始就已经确定了
  while (stack.length > 0) {
    const lastItem = stack.pop();

    if (Array.isArray(lastItem.value) && depth >= lastItem.deep) {
      const newStack = lastItem.value.map((element) => ({
        value: element,
        deep: lastItem.deep + 1,
      }));
      stack.push(...newStack);
    } else {
      lastItem.value !== undefined && result.unshift(lastItem.value);
    }
  }
  return result;
}
```

> JS 引擎对 conact 有优化？处理大量数据时，比拓展运算符好
