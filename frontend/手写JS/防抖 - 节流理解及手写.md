防抖和节流都是做性能优化的方案，它们功能相近，经常会一并提及，但却又有不同的适用场景。


# 防抖
所谓的防抖，其实是h函数的一种特性，可以描述为：

> 一个具有防抖特性的函数被触发时，它将等待特定时间后“执行”，但如果在等待期间被再次触发，则重新计时。

我们平常说的“防抖函数”，通常指的是“能返回具有防抖特性函数的函数”。也就是说所谓的防抖函数是一个高阶函数，它本身并不具有防抖的特性，而是经过它包装之后，所返回的函数具有防抖特性。


为了实现在等待时间内重复调用函数时，会重新计时的特点，则需要借助闭包的特点，在父级函数中定义变量，使返回出去的闭包函数在每次运行时，都能访问到同一个变量（再去做相应的逻辑判断），而不是重新生成局部变量（这样无法在多次调用时共享状态）。

具体实现如下所示：

```javascript

// 防抖：如果在限定的延迟时间内重复触发，则重新开始计时，只在最后一次触发中执行函数。
function debounce(fn, delay) {
  // 在父级函数中定义，使返回的闭包函数在多次调用时，能访问到同一个变量
  let timer = null;

  return function () {
    // 每次执行函数时，清除上一次可能存在的延时器
    timer && clearTimeout(timer);

    const args = arguments;
    timer = setTimeout(() => {
      // this绑定为闭包函数运行时的this指向
      fn.apply(this, args);
    }, delay);
  };
}

```

箭头函数被声明的时间是在setTimeout执行的瞬间（或者说前一刻），此刻箭头函数的this执行会继承上层作用域的this指向，也就是返回出去的闭包函数的this指向。所以防抖函数返回出去的“真正的防抖函数”是可以按照需求绑定this指向的。



```javascript

// 节流：函数被调用后马上执行，并在限定时间内只会执行一次（即使期间被重复触发）
function throttle(fn, delay) {
  // 在父级函数中定义，使多次调用返回的闭包函数能访问到同一个变量
  let timer = null;

  return function () {
    if (timer === null) {
      fn.apply(this, arguments);

      timer = setTimeout(() => {
        timer = null;
      }, delay);
    }
  };
}

// =========测试用例==========

function print(x, y, z) {
  console.log('打印：', x, y, z, this.text)
}
// 用于测试this指向是否绑定成功
const obj = {
  text: 'hello world'
}
const dePrint = debounce(print, 1000)
const throPrint = throttle(print, 1000)

// 防抖函数测试函数
function testDebounce() {
  let count = 0 

  let timer = setInterval(() => {
    dePrint.apply(obj, [1,2,3])
    count++
    // 每隔500毫秒尝试触发一次，共尝试4次
    if (count === 4) clearInterval(timer)
  }, 500)
}

// 节流函数测试函数
function testThrottle() {
  let count = 0 

  let timer = setInterval(() => {
    throPrint.apply(obj, [1,2,3])
    count++
    // 每隔500毫秒尝试触发一次，共尝试4次
    if (count === 4) clearInterval(timer)
  }, 500)
}

testDebounce() // 最终只会在最后一次运行dePrint
testThrottle() // 最终会成功运行2次

```